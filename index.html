<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gravity Elements</title>
    <style>
        .world > * {
            position: relative;
            overflow: hidden;
        }

        .world {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        .fake-engine {
            display: flex;
            flex-direction: column;
            justify-self: space-between;
            align-items: center;
        }

        .fake-engine > h1 {
            font-size: 4em;
            font-family: 'Liberation Serif', serif;
        }

        .fake-engine-buttons > button {
            margin: .2em;
            font-size: 0.8em;
            padding: .1em 1em .1em 1em;
        }
        
        .fake-engine > input[type="text"] {
            margin: .2em;
            width: 35em;
        }
        
        .fake-engine-buttons {
            display: flex;
            flex-direction: row;
            justify-self: center;
            align-items: center;
            margin-bottom: 3em;
        }

        .fake-engine-footer {
            color: gray;
            font-size: .8em;
            text-decoration: underline;
            margin-top: 2em;
        }

        .fake-engine-counter {
            font-size: .8em;
        }

        .go-crazy {
          animation: rotation 2s infinite linear, crazy 4s infinite linear;
        }

        .dialog {
            /* Style your dialog here (background, border, padding, etc.) */
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border: 1px solid #ddd;
            z-index: 10;
        }
        .dialog-overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent black background */
          display: none;
          z-index: 9; /* Set slightly lower than dialog */
        }
        .dialog-buttons {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }

        .dialog-buttons > button {
            margin: .5em;
            flex: 1;
        }

        .link-title {
            
        }
        @keyframes rotation {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }

        @keyframes crazy {
          0% {
            transform: scale(0.8) rotate(0deg);
            background-color: #ff0000;
            border: 5px solid white;
          }
          25% {
            transform: scale(1.2) rotate(360deg);
            background-color: #00ff00;
            border: 5px solid black;
          }
          50% {
            transform: scale(0.5) skewX(30deg) skewY(-20deg);
            background-color: #0000ff;
            border: none;
          }
          75% {
            transform: scale(1.5) translateX(50px) translateY(-20px);
            background-color: #ffff00;
            box-shadow: 0px 0px 10px #ff00ff;
          }
          100% {
            transform: scale(0.8) rotate(-360deg);
            background-color: #ff0000;
            border: 5px solid white;
          }
        }
    </style>
</head>

<body>
    <div class="dialog-overlay"></div>
    <dialog id="warning-dialog" class="dialog">
        <h2>Warning!</h2>
        <p>FakeEngine is going to enter crazy mode. You might encounter <b>flashing images</b> and <b>moving objects</b>. <i>Continue?</i></p>
        <div class="dialog-buttons">
            <button id="yes-button">Yes</button>
            <button id="no-button">No</button>        
        </div>
    </dialog>
    <div class="world" id="world">
        <div class="fake-engine" id="fake-engine">
            <h1>FakeEngine</h1>
            <input type="text" placeholder="Search the fake web...">
            <div class="fake-engine-buttons">
                <button onclick="fall()">Search</button>
                <button onclick="go_crazy()">I'm feeling crazy</button>
            </div>
            <div class="fake-engine-counter">
                FakeEngine index: <span id="fake-engine-counter">1,000,000</span>+ pages
            </div>
            <div class="fake-engine-footer">
                <small>&copy; 2069 Nobody</small>
            </div>
            <div class="link-block">
                <a href="#" class="link-title">Epic images!</a>
            </div>
        </div>
    </div>
</body>
<script>
const fake_engine_counter_element = document.getElementById("fake-engine-counter")
let fake_engine_counter = 1500400
let fake_engine_counting = true

const world = document.getElementById("world");

const elements = [];
const restitution = 0.2;
const gravity = 0.0058;
const maxAngularVelocity = 5; // Adjust for desired rotation speed

const addExisting = (qs, leftPosition, clickHandler) => {
    const element = document.querySelector(qs);
    const rect = element.getBoundingClientRect();

    element.onclick = clickHandler;
    element.style.width = 'fit-content';

    elements.push({
        position: { y: rect.top - 1, x: rect.left - 1 },
        velocity: { y: 0, x: 0 },
        element,
        angle: 0,
    });

    return element;
};

const addElement = (elementType, innerHTML, leftPosition, clickHandler) => {
    const element = document.createElement(elementType);

    element.innerHTML = innerHTML;
    element.onclick = clickHandler;
    element.style.width = 'fit-content';

    element.addEventListener("mousedown", (event) => {
        offsetX = event.clientX - element.offsetLeft;
        offsetY = event.clientY - element.offsetTop;
    });

    element.addEventListener("mousemove", (event) => {
        if (!element.dragging) return;
        element.style.left = event.clientX - offsetX + "px";
        element.style.top = event.clientY - offsetY + "px";
    });

    element.addEventListener("mouseup", () => {
        element.dragging = false;
    });

    element.style.left = leftPosition + "px"

    elements.push({
        position: { y: Math.random() * 2e+2, x: leftPosition },
        velocity: { y: 0, x: 0 },
        element,
        angle: 0,
        fallVelocity: 1000,
    });

    world.appendChild(element);

    return element;
};

const process_frame = () => {

    for (let i = 0; i < elements.length; i++) {
        const elementData = elements[i];
        const element = elementData.element;
        const position = elementData.position;
        const velocity = elementData.velocity;
        const fallVelocity = elementData.fallVelocity;
        const angle = elementData.angle;

        const elementHeight = elementData.element.offsetHeight;
        const elementWidth = elementData.element.offsetWidth;

        position.y += velocity.y;

        if (position.y + elementHeight > window.innerHeight) {
            position.y = window.innerHeight - elementHeight;
            velocity.y = -velocity.y * restitution;
        }

        element.style.top = position.y + "px";
        velocity.y += gravity;

        for (let j = i + 1; j < elements.length; j++) {
            if (i !== j) {
                const otherElementData = elements[j];
                const otherPosition = otherElementData.position;
                const otherHeight = otherElementData.height;

                if (
                    position.x < otherPosition.x + elementData.width &&
                    position.x + elementWidth > otherPosition.x &&
                    position.y < otherPosition.y + otherHeight &&
                    position.y + elementHeight > otherPosition.y
                ) {
                    position.y = otherPosition.y - elementHeight;

                    const mass1 = 1;
                    const mass2 = 1;

                    const velocityX1 =
                        (velocity.x * mass1 +
                            otherElementData.velocity.x * mass2 * (restitution + 1)) /
                        (mass1 + mass2);
                    const velocityX2 =
                        (otherElementData.velocity.x * mass2 +
                            velocity.x * mass1 * (restitution + 1)) /
                        (mass1 + mass2);

                    velocity.x = velocityX1;
                    otherElementData.velocity.x = velocityX2;

                    position.y -= 1;
                    otherPosition.y += 1;

                    elementData.angle += Math.random() * 10;
                    otherElementData.angle -= Math.random() * 10;
                }
            }
        }

        // Update angle based on scaled velocity (capped for stability)
        const angularVelocity = Math.min(Math.abs(velocity.y), maxAngularVelocity);
        elementData.angle += (velocity.y > 0 ? -1 : 1) * angularVelocity;

        // Ensure angle is always between -180 and 180 degrees
        elementData.angle = elementData.angle % 360;

        if (elementData.angle < 0) {
            elementData.angle += 360;
        }

        // Gradually dampen rotation as velocity approaches zero
        if (Math.abs(velocity.y) < 0.1) {
            elementData.angle = Math.round(elementData.angle);
        }

        element.style.transform = `rotate(${angle}deg)`;
    }
};

const requestFullscreen = (element) => {
    if (!element) {
        return; // Handle potential undefined element
    }

    if (element.requestFullscreen) {
        element.requestFullscreen();
    } else if (element.webkitRequestFullscreen) { // Webkit prefix for Safari
        element.webkitRequestFullscreen();
    } else if (element.mozRequestFullScreen) { // Mozilla prefix for Firefox
        element.mozRequestFullScreen();
    } else {
        console.error("Fullscreen API not supported by your browser.");
    }
}

const exitFullscreen = () => {
    if (document.fullscreenElement) {
        document.exitFullscreen();
    } else if (document.webkitIsFullScreen) { // Webkit prefix for Safari
        document.webkitExitFullscreen();
    } else if (document.mozCancelFullScreen) { // Mozilla prefix for Firefox
        document.mozCancelFullScreen();
    } else {
        console.error("Fullscreen API not supported by your browser.");
    }
}

let fake_index_timer = setInterval(() => {
    if (fake_engine_counting) {
        fake_engine_counter += 10
        fake_engine_counter_element.innerHTML = fake_engine_counter.toLocaleString()

        if (fake_engine_counter > 1e+10) fake_engine_counting = false
    }
}, 50)


const fall = () => {
    world.style.position = "absolute";

    for (let element of document.querySelectorAll(".world > *")) {
        addExisting(`#${element.id}`, Math.min(Math.max(Math.floor(Math.random() * 10e+2)), element.offsetWidth), window.innerWidth - element.offsetWidth)
    }

    let frame_timer = setInterval(process_frame, 1);
}

const warningDialog = document.getElementById("warning-dialog");
const yesButton = document.getElementById("yes-button");
const noButton = document.getElementById("no-button");
const dialogOverlay = document.querySelector(".dialog-overlay");
yesButton.addEventListener("click", () => {
    requestFullscreen(document.querySelector("html"));
    document.querySelector("body").classList.add("go-crazy");
    warningDialog.style.display = "none";
    dialogOverlay.style.display = "none";
});

noButton.addEventListener("click", () => {
    warningDialog.style.display = "none";
    dialogOverlay.style.display = "none";
});

const go_crazy = () => {
    warningDialog.style.display = "block";
    dialogOverlay.style.display = "block";
}
</script>

</html>